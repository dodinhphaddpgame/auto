import os
import time
import cv2
import numpy as np
from typing import Optional, Tuple, List
import screenshot
# add tkinter for non-blocking name prompt
import tkinter as tk
from tkinter import simpledialog

class ImageTemplateMaker:
    """
    Interactive ROI selector & template saver that accepts an image (numpy BGR).
    Controls:
        - Left mouse drag: select ROI
        - 's' : save current ROI (prompt via GUI dialog)
        - 'a' : auto-save ROI with autogenerated name (no prompt)
        - 'r' : reset selection
        - 'q' or ESC : quit
    """
    def __init__(self, image: np.ndarray, win_name: str = "TemplateMaker", templates_dir: str = "templates", use_gui_prompt: bool = True):
        if image is None or not isinstance(image, np.ndarray):
            raise ValueError("image must be a numpy.ndarray (BGR).")
        self.orig_img = image.copy()
        self.img = image.copy()
        self.preview = self.img.copy()
        self.win_name = win_name
        self.templates_dir = templates_dir
        os.makedirs(self.templates_dir, exist_ok=True)

        # ROI vars
        self.dragging = False
        self.start_pt: Tuple[int,int] = (0,0)
        self.end_pt: Tuple[int,int] = (0,0)
        self.roi: Optional[Tuple[int,int,int,int]] = None  # x1,y1,x2,y2

        # prompt mode
        self.use_gui_prompt = use_gui_prompt

        # Setup window & callback
        cv2.namedWindow(self.win_name, cv2.WINDOW_NORMAL)
        cv2.setMouseCallback(self.win_name, self._mouse_cb)

    def _mouse_cb(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            self.dragging = True
            self.start_pt = (x, y)
            self.end_pt = (x, y)
            self.preview = self.img.copy()
            self.roi = None
        elif event == cv2.EVENT_MOUSEMOVE and self.dragging:
            self.end_pt = (x, y)
            self.preview = self.img.copy()
            cv2.rectangle(self.preview, self.start_pt, self.end_pt, (0,255,0), 2)
        elif event == cv2.EVENT_LBUTTONUP:
            self.dragging = False
            self.end_pt = (x, y)
            self._finalize_roi()

    def _finalize_roi(self):
        x1,y1 = self.start_pt
        x2,y2 = self.end_pt
        x_min, x_max = sorted((x1,x2))
        y_min, y_max = sorted((y1,y2))
        # clamp to image
        x_min = max(0, min(self.img.shape[1]-1, x_min))
        x_max = max(0, min(self.img.shape[1]-1, x_max))
        y_min = max(0, min(self.img.shape[0]-1, y_min))
        y_max = max(0, min(self.img.shape[0]-1, y_max))
        if x_max - x_min <= 2 or y_max - y_min <= 2:
            self.roi = None
            self.preview = self.img.copy()
            return
        self.roi = (x_min, y_min, x_max, y_max)
        self.preview = self.img.copy()
        cv2.rectangle(self.preview, (x_min, y_min), (x_max, y_max), (0,255,0), 2)

    def get_roi_image(self) -> Optional[np.ndarray]:
        if self.roi is None:
            return None
        x1,y1,x2,y2 = self.roi
        return self.orig_img[y1:y2, x1:x2].copy()

    def save_roi(self, name: Optional[str] = None) -> Optional[str]:
        roi_img = self.get_roi_image()
        if roi_img is None:
            print("No ROI selected to save.")
            return None
        if name is None or name.strip() == "":
            name = time.strftime("tpl_%Y%m%d_%H%M%S")
        # sanitize filename
        name = "".join(c for c in name if c.isalnum() or c in ("-","_")).strip()
        filename = os.path.join(self.templates_dir, f"{name}.png")
        cv2.imwrite(filename, roi_img)
        print("Saved template:", filename)
        return filename

    def reset_selection(self):
        self.roi = None
        self.preview = self.img.copy()

    def _prompt_name_gui(self, prompt_text="Template name"):
        """
        Use tkinter.simpledialog to prompt for a string.
        This creates a short-lived Tk root and destroys it after.
        """
        root = tk.Tk()
        root.withdraw()  # hide main window
        try:
            # on some platforms askstring will block until user closes dialog, that's OK
            val = simpledialog.askstring(title="Save template", prompt=prompt_text, parent=root)
        finally:
            try:
                root.destroy()
            except Exception:
                pass
        return val

    def run(self) -> List[str]:
        """
        Start interactive UI. Returns list of saved file paths.
        """
        saved_files: List[str] = []
        print("Template maker started. Drag to select ROI.")
        print("Keys: s=save (prompt), a=auto-save, r=reset, q=quit")
        while True:
            # show preview
            cv2.imshow(self.win_name, self.preview)
            key = cv2.waitKey(20) & 0xFF
            if key == ord('s'):
                if self.roi is None:
                    print("No ROI selected.")
                else:
                    # Use GUI prompt instead of input() to avoid blocking main loop
                    if self.use_gui_prompt:
                        name = self._prompt_name_gui("Enter template name (Cancel to abort):")
                        if name is None:
                            print("Canceled.")
                        else:
                            p = self.save_roi(name)
                            if p:
                                saved_files.append(p)
                    else:
                        # fallback: console input (blocking)
                        name = input("Enter template name (empty to cancel): ").strip()
                        if name == "":
                            print("Canceled.")
                        else:
                            p = self.save_roi(name)
                            if p:
                                saved_files.append(p)

            elif key == ord('a'):
                if self.roi is None:
                    print("No ROI selected.")
                else:
                    p = self.save_roi()  # auto name
                    if p:
                        saved_files.append(p)
            elif key == ord('r'):
                self.reset_selection()
                print("Selection reset.")
            elif key == ord('q') or key == 27:
                break
            # continue loop
        cv2.destroyWindow(self.win_name)
        return saved_files

def make_templates_from_image(image: np.ndarray, templates_dir: str = "templates") -> List[str]:
        maker = ImageTemplateMaker(image, templates_dir=templates_dir)
        return maker.run()


if __name__ == "__main__":
    # img = d.capture_window_by_hwnd(c.gethwnd("LDPlayer-4", target = "child"))
    img = screenshot.screenshot(window_title="LDPlayer-1", target="child")
    # img = cv2.imread("templates/tpl_20251010_141826.png") # or your capture function result
    saved = make_templates_from_image(img)
    print("Saved templates:", saved)